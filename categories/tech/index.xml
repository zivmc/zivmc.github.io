<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tech on Ziv&#39;s Blog</title>
    <link>https://zivmc.github.io/categories/tech/</link>
    <description>Recent content in tech on Ziv&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Dec 2019 16:03:01 +0800</lastBuildDate>
    
	<atom:link href="https://zivmc.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android 智能指针</title>
      <link>https://zivmc.github.io/posts/android-smart-pointer/</link>
      <pubDate>Thu, 12 Dec 2019 16:03:01 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/android-smart-pointer/</guid>
      <description>最近看了下 Android 中智能指针的实现，这里简单记一下。使用的源码是 Android-8.1.0_r1，不同版本 Android 在这一块的实现差异还是比较小的。
智能指针简介 以 C++ 标准库的 shared_ptr 为例，每次有新的 shared_ptr 指向同一个对象，这个对象的引用计数就会加 1；当一个 shared_ptr 不再指向这个对象时，这个对象的引用计数就会减 1；当引用计数减为 0 时，就将这个对象释放掉。实现的大致思路就是在智能指针的构造函数中引用计数加 1，在析构函数中引用计数减 1。
当对象 A 有对象 B 的智能指针作为成员变量，对象 B 也有对象 A 的智能指针作为成员变量时，由于同时只能释放一个对象，尝试释放 A 时，发现 A 还被 B 引用，A 就不会被释放，尝试释放 B 时也是类似的。这样 A 和 B 在程序退出之前就不会被释放掉，实际上造成了内存泄露。
为了解决上面的相互引用问题，又有了 weak_ptr 的概念，weak_ptr 指向一个对象时，不会增加这个对象的（强）引用计数。如果把上面 A 和 B 中的智能指针替换为 weak_ptr，那么相互引用就不会影响对象的释放了。
Android 中的智能指针在行为上跟上面的介绍基本是一致的，有强指针类型 sp 和弱指针类型 wp，对应分别有强引用计数和弱引用计数。智能指针的源码就是下面这三个文件：
system/core/libutils/include/utils/StrongPointer.h system/core/libutils/include/utils/RefBase.h system/core/libutils/RefBase.cpp 其中 StrongPointer.h 中是强指针 sp 这个模板类的定义和实现；RefBase.h 中有弱指针 wp 这个模板类的定义和实现，以及 RefBase 等几个关键类的定义；RefBase.</description>
    </item>
    
    <item>
      <title>指针、数组和 const</title>
      <link>https://zivmc.github.io/posts/pointer-array-and-const/</link>
      <pubDate>Fri, 15 Nov 2019 14:43:39 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/pointer-array-and-const/</guid>
      <description>上一篇看了初始化和未初始化的指针，这次写了几个例子接着看一下指针、数组和 const 修饰符。
例1：指针与数字相加 /* 1.array.c */ #include &amp;lt;stdio.h&amp;gt; int main() { int a[5] = {0, 1, 2, 3, 4}; int *pi = a; long addr = (long)a; printf(&amp;#34;sizeof a: %lu\n&amp;#34;, sizeof(a)); printf(&amp;#34;count a: %lu\n&amp;#34;, sizeof(a)/sizeof(*a)); printf(&amp;#34;a: %p\n&amp;#34;, a); printf(&amp;#34;a + 1: %p\n&amp;#34;, a + 1); printf(&amp;#34;a + 4: %p\n&amp;#34;, a + 4); printf(&amp;#34;*(a + 1): %d\n&amp;#34;, *(a + 1)); printf(&amp;#34;*(a + 4): %d\n&amp;#34;, *(a + 4)); printf(&amp;#34;&amp;amp;a[0]: %p\n&amp;#34;, &amp;amp;a[0]); printf(&amp;#34;&amp;amp;a[1]: %p\n&amp;#34;, &amp;amp;a[1]); printf(&amp;#34;&amp;amp;a[4]: %p\n&amp;#34;, &amp;amp;a[4]); printf(&amp;#34;pi: %p\n&amp;#34;, pi); printf(&amp;#34;pi + 1: %p\n&amp;#34;, (pi + 1)); printf(&amp;#34;addr: 0x%lx\n&amp;#34;, addr); printf(&amp;#34;addr + 1: 0x%lx\n&amp;#34;, addr + 1); printf(&amp;#34;\nchar array:\n&amp;#34;); char c[5] = {&amp;#39;h&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;}; printf(&amp;#34;sizeof c: %lu\n&amp;#34;, sizeof(c)); printf(&amp;#34;count c: %lu\n&amp;#34;, sizeof(c)/sizeof(*c)); printf(&amp;#34;c: %p\n&amp;#34;, c); printf(&amp;#34;c + 1: %p\n&amp;#34;, c + 1); printf(&amp;#34;*c: %c\n&amp;#34;, *c); printf(&amp;#34;*(c + 1): %c\n&amp;#34;, *(c + 1)); printf(&amp;#34;*c: %u\n&amp;#34;, *c); return 0; }  sizeof(数组名) 返回整个数组占用的字节数 sizeof(指针) 返回指针本身的大小，对于 64 位机器来说就是 8 指针和数组名加 1，得到的都是下一个元素的地址 指针强转成 long 之后，加上元素的大小，可以得到下一个元素的地址，不过这样做没什么意义  例2：指针与字符串 /* 2.</description>
    </item>
    
    <item>
      <title>gdb 查看 C 中未初始化的指针</title>
      <link>https://zivmc.github.io/posts/check-pointers-with-gdb/</link>
      <pubDate>Wed, 13 Nov 2019 17:11:31 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/check-pointers-with-gdb/</guid>
      <description>C 的指针这一块学得不是特别好，最近准备深入看一下，这里先用看一下 C 中未初始化的指针相关的问题。
使用 gdb  编译时输出调试信息：使用 -g 编译选项 打开文件：gdb a.out 查看源码：list 或 l，可以跟行号 设置断点：break 或 b，可以跟行号 开始运行：run 或者 r 继续运行到下一行：next 或者 n 继续运行到下一断点：continue 或者 c 查看进程映射信息：i proc mapping 或者 info proc mapping，可以看到堆和栈的起始地址 查看段映射信息：i files 或者 info files，可以看到每个段的起始和终止地址 打印变量信息：print 或者 p，后面可以跟变量名、表达式等 打印指定地址：x/4xb [addr]，addr 可以是地址，也可以是变量名。b 表示打印字节，x 表示打印 16 进制格式，4 表示打印 4 个（字节）  未初始化的指针 调试代码 下面代码中 gi 是初始化的全局变量，gn 是未初始化的全局变量，spi 是初始化的静态指针变量，spn 是未初始化的静态指针变量，pi2 是未初始化的局部指针变量：
/* 0.global_and_local.c */ #include &amp;lt;stdio.h&amp;gt; int gi = 5; int gn; static int *spi = &amp;amp;gi; static int *spn; int main() { int j = 6; int *pi = &amp;amp;j; printf(&amp;#34;===== local variables:\n&amp;#34;); printf(&amp;#34;&amp;amp;j: %p\n&amp;#34;, &amp;amp;j); printf(&amp;#34;pi: %p\n&amp;#34;, pi); printf(&amp;#34;&amp;amp;pi: %p\n&amp;#34;, &amp;amp;pi); int *pi2; printf(&amp;#34;pi2: %p\n&amp;#34;, pi2); pi2 = NULL; printf(&amp;#34;pi2: %p\n&amp;#34;, pi2); printf(&amp;#34;\n===== global variables:\n&amp;#34;); printf(&amp;#34;gi: %d\n&amp;#34;, gi); printf(&amp;#34;&amp;amp;gi: %p\n&amp;#34;, &amp;amp;gi); printf(&amp;#34;gn: %d\n&amp;#34;, gn); printf(&amp;#34;&amp;amp;gn: %p\n&amp;#34;, &amp;amp;gn); printf(&amp;#34;spi: %p\n&amp;#34;, spi); printf(&amp;#34;&amp;amp;spi: %p\n&amp;#34;, &amp;amp;spi); printf(&amp;#34;spn: %p\n&amp;#34;, spn); printf(&amp;#34;&amp;amp;spn: %p\n&amp;#34;, &amp;amp;spn); return 0; } 编译 gcc -g 0.</description>
    </item>
    
    <item>
      <title>Android 硬件抽象层相关的一组例子</title>
      <link>https://zivmc.github.io/posts/hal-examples-from-kernel-driver-to-an-application/</link>
      <pubDate>Tue, 12 Nov 2019 19:29:38 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/hal-examples-from-kernel-driver-to-an-application/</guid>
      <description>最近读了《Android 系统源代码情景分析》一书的第二章，通过一组硬件抽象层相关的例子，从内核到应用层完整地介绍了 Android 的体系结构。这组例子包括：
 在内核中添加一个字符设备驱动 在硬件抽象层添加对应的硬件抽象层模块 在 Framework 和 Native Framework 层添加访问服务 最后开发一个 Android 应用使用 Framework 层的服务  原书使用的代码比较老，Android 版本是 2.3.1，内核版本是 2.6.29，例子中的很多代码在较新版本的 Android 上已经不再适用。这里对书中的例子做了一些修改，使之能在较新版本的 Android 设备上运行和调试。
这里使用的环境：
 设备是 Nexus 5X（bullhead） Android 版本是 android-8.1.0_r1，lunch 选项是 aosp_bullhead-userdebug 内核分支是 remotes/origin/android-msm-bullhead-3.10-oreo-mr1  用文字讲代码实在是一件很吃力的事情，因此这里直接给出以下所有代码的 链接，以下只简单介绍代码做了什么，适配了哪些地方等。
向内核添加驱动程序 书中这部分代码用到的一些接口在 v3.10 的内核上已经不再可用，这里直接使用 http://derekmolloy.ie 给出的添加驱动程序的代码。
ebbchar.c 即为驱动的代码，作用是创建 /dev/ebbchar 这个设备，并实现对这个设备进行读写时的处理操作。用户可以使用 read 和 write 函数对 /dev/ebbchar 这个设备进行字符串的读写。
ebbchar.c 置于 &amp;ldquo;kernel/drivers/ebbchar/&amp;rdquo; 目录下，并添加、修改相关的 Kconfig、Makefile 文件之后，重新编译内核即可。
 编译和替换内核在 Nexus 5X 编译替换 AOSP msm 内核 这篇文章里有介绍。</description>
    </item>
    
    <item>
      <title>使用 openssl 对文件签名和验签</title>
      <link>https://zivmc.github.io/posts/use-openssl-to-sign-and-verify-files/</link>
      <pubDate>Sun, 10 Nov 2019 11:31:17 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/use-openssl-to-sign-and-verify-files/</guid>
      <description>这里介绍三个点：文件签名和验签做了什么，openssl 命令行工具进行签名和验签，在 C 程序中调用 openssl 接口进行签名和验签。
 其中 C 程序验签的例子来自 PAGE FAULT BLOG，原文没有签名的例子，这里补上了。
 文件签名和验签 签名 有文件 test.txt，使用摘要算法（如 SHA256）计算出文件的摘要，再使用私钥（private.pem）对摘要的内容做加密，就叫做文件签名，摘要加密之后的内容叫做文件的签名（记 test.sig）。
验签 私钥 private.pem 对应的公钥是 public.pem，使用公钥对 test.sig 解密得到加密前的摘要 digest1，再计算 test.txt 的摘要得到 digest2，如果 digest1 和 digest2 相同，则验签成功。
openssl 命令行工具使用 生成私钥 private.pem:
openssl genrsa -out private.pem 1024 生成公钥：
openssl rsa -in private.pem -pubout -out public.pem 计算 SHA256 摘要并用 private.pem 生成签名文件 test.sig:
openssl dgst -sha256 -sign private.pem -out test.sig test.txt 使用公钥验证签名：
openssl dgst -sha256 -verify public.</description>
    </item>
    
    <item>
      <title>Nexus 5X 编译替换 AOSP msm 内核</title>
      <link>https://zivmc.github.io/posts/build-and-replace-aosp-msm-kernel/</link>
      <pubDate>Fri, 01 Nov 2019 10:32:04 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/build-and-replace-aosp-msm-kernel/</guid>
      <description>最近开始看 《Android 系统源代码情景分析》这本书，手上有一个 Nexus 5X 用来调试。这里记录一下编译替换内核的方法。
下载代码 Google 其实给了编译内核的文档，在这里。
 上面的链接是 Pixel 之前设备的内核编译方法，Google 为 Pixel 之后的设备做了另一套编译工具，在上面的页面中也可以找到链接。
 下载 msm 内核代码就直接使用 git：
git clone https://android.googlesource.com/kernel/msm 如果是其他设备，就下载对应的 git 仓库。内核代码也可以用国内的 AOSP 镜像，如：
git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm 下载代码之后需要找一个对应 Nexus 5X 的分支。我这里 Nexus 5X 刷的是 android-8.1.0_r1 (aosp_bullhead-userdebug):
git branch -a | grep &amp;#34;3.10&amp;#34; | grep &amp;#34;bullhead&amp;#34; | grep &amp;#34;oreo&amp;#34; 从结果中选一个分支 checkout 出来：
git checkout remotes/origin/android-msm-bullhead-3.10-oreo-mr1  上面这个分支实测在 Nexus 5X, android-8.1.0_r1, aosp_bullhead-userdebug 上可以正常使用。有些分支可能出现编译刷入后系统正确启动的情况。
 编译内核 编译内核需要 arm 的交叉编译工具链，使用设备镜像对应 Android 源码目录下的即可：</description>
    </item>
    
    <item>
      <title>subprocess 模块使用 bash 运行命令并捕捉输出</title>
      <link>https://zivmc.github.io/posts/python-subprocess-capture-output/</link>
      <pubDate>Mon, 28 Oct 2019 16:50:52 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/python-subprocess-capture-output/</guid>
      <description>背景是使用 Python 写脚本编译 Android 10 源码时，源码的某些 Makefile 文件会检查正在使用的 shell，并根据使用的 shell 是 bash 或 zsh，定义不同的 check_type() 函数：
function validate_current_shell() { local current_sh=&amp;#34;$(ps -o command -p $$)&amp;#34; case &amp;#34;$current_sh&amp;#34; in *bash*) function check_type() { type -t &amp;#34;$1&amp;#34;; } ;; *zsh*) function check_type() { type &amp;#34;$1&amp;#34;; } enable_zsh_completion ;; *) echo -e &amp;#34;WARNING: Only bash and zsh are supported.\nUse of other shell would lead to erroneous results.&amp;#34; ;; esac } 之前实现的脚本中，os.system() 函数，以及默认的 subprocess 模块，都会调用 /bin/sh 执行命令。尽管 /bin/sh 指向的是 /bin/bash，这里还是不能正确定义出 check_type() 函数。</description>
    </item>
    
    <item>
      <title>从 Android 6.0 factory image 中提取驱动</title>
      <link>https://zivmc.github.io/posts/android-6.0-extract-drivers-from-factory-image/</link>
      <pubDate>Thu, 10 Oct 2019 01:07:49 +0800</pubDate>
      
      <guid>https://zivmc.github.io/posts/android-6.0-extract-drivers-from-factory-image/</guid>
      <description>背景是 Google 的 Driver Binaries 页面不提供 Android 6.0 的驱动，Android 6.0 之前和之后的驱动都有提供。这里介绍一种使用 android-prepare-vendor 工具从 factory image 中提取驱动的方法。
准备 工具  android-prepare-vendor 工具 android-prepare-vendor 依赖的其他工具，android-simg2img、dexRepair 等，可根据 android-prepare-vendor 运行时的错误信息搜索安装  修改 android-prepare-vendor 我使用的最新 commit 为 e853d17c89f6962d3fd6f408db8576e6b445f643 的版本，在处理中间文件时会有一些权限问题，因此需要打上下面这个 patch：
diff --git a/scripts/generate-vendor.sh b/scripts/generate-vendor.sh index b7c96a5..a601ac4 100755 --- a/scripts/generate-vendor.sh +++ b/scripts/generate-vendor.sh @@ -217,6 +217,10 @@ extract_blobs() { # writing to destination) outPath=&amp;#34;$outBase/$dstDir/$(basename &amp;#34;$src&amp;#34;)&amp;#34; + if test -f &amp;#34;$outPath&amp;#34;; then + chmod +rwx $outPath + fi + cp -a &amp;#34;$inDir/$src&amp;#34; &amp;#34;$outPath&amp;#34; || { echo &amp;#34;[-] Failed to copy &amp;#39;$src&amp;#39;&amp;#34; abort 1 -- 2.</description>
    </item>
    
  </channel>
</rss>